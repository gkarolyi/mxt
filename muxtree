#!/usr/bin/env bash
set -euo pipefail

# ─────────────────────────────────────────────────────────────────────────────
# muxtree — Tmux Worktree Session Manager
# Create and manage git worktrees + tmux sessions for AI coding agents
# ─────────────────────────────────────────────────────────────────────────────

VERSION="1.0.0"
CONFIG_DIR="${MUXTREE_CONFIG_DIR:-$HOME/.muxtree}"
CONFIG_FILE="$CONFIG_DIR/config"

# ── Defaults ──────────────────────────────────────────────────────────────────
DEFAULT_WORKTREE_DIR="$HOME/worktrees"
DEFAULT_TERMINAL="terminal"  # terminal | iterm2 | ghostty | current
DEFAULT_COPY_FILES=""
DEFAULT_PRE_SESSION_CMD=""   # Command to run after worktree setup, before tmux
DEFAULT_TMUX_LAYOUT=""       # Tmux layout: "window:cmd1|cmd2,window2:cmd" or multi-line with []

# ── Colors ────────────────────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'

if [[ ! -t 1 ]]; then
    RED='' GREEN='' YELLOW='' BLUE='' CYAN='' BOLD='' DIM='' RESET=''
fi

# ── Helpers ───────────────────────────────────────────────────────────────────

logo() {
    cat <<'LOGO'
                       _
  _ __ ___  _   ___  _| |_ _ __ ___  ___
 | '_ ` _ \| | | \ \/ / __| '__/ _ \/ _ \
 | | | | | | |_| |>  <| |_| | |  __/  __/
 |_| |_| |_|\__,_/_/\_\\__|_|  \___|\___|
LOGO
    echo -e "  ${DIM}Tmux Worktree Session Manager v$VERSION${RESET}"
}

info()    { echo -e "${BLUE}▸${RESET} $*"; }
success() { echo -e "${GREEN}✓${RESET} $*"; }
warn()    { echo -e "${YELLOW}⚠${RESET} $*"; }
error()   { echo -e "${RED}✗${RESET} $*" >&2; }
die()     { error "$@"; exit 1; }

_parse_config() {
    local file="$1"
    local in_multiline=false
    local multiline_key=""
    local multiline_value=""

    while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// /}" ]] && continue

        # Handle multi-line array syntax: key=[...]
        if [[ "$line" =~ ^[[:space:]]*([a-z_]+)[[:space:]]*=[[:space:]]*\[(.*) ]]; then
            in_multiline=true
            multiline_key="${BASH_REMATCH[1]}"
            multiline_value="${BASH_REMATCH[2]}"

            # Check if it closes on same line
            if [[ "$multiline_value" =~ (.*)\][[:space:]]*$ ]]; then
                multiline_value="${BASH_REMATCH[1]}"
                in_multiline=false
                _parse_config_set "$multiline_key" "$multiline_value"
            fi
            continue
        fi

        # Continue collecting multi-line value
        if $in_multiline; then
            if [[ "$line" =~ ^[[:space:]]*(.*)\][[:space:]]*$ ]]; then
                # End of multi-line value
                multiline_value+=" ${BASH_REMATCH[1]}"
                in_multiline=false
                _parse_config_set "$multiline_key" "$multiline_value"
            else
                # Continue accumulating
                multiline_value+=" $line"
            fi
            continue
        fi

        # Handle single-line key=value
        if [[ "$line" =~ ^[[:space:]]*([a-z_]+)[[:space:]]*=[[:space:]]*(.*)$ ]]; then
            local key="${BASH_REMATCH[1]}"
            local value="${BASH_REMATCH[2]}"
            _parse_config_set "$key" "$value"
        fi
    done < "$file"
}

_parse_config_set() {
    local key="$1"
    local value="$2"

    # Trim whitespace
    key="${key#"${key%%[![:space:]]*}"}"
    key="${key%"${key##*[![:space:]]}"}"
    value="${value#"${value%%[![:space:]]*}"}"
    value="${value%"${value##*[![:space:]]}"}"

    # For tmux_layout, convert commas and newlines to semicolons
    if [[ "$key" == "tmux_layout" ]]; then
        # Replace commas with semicolons
        value="${value//,/;}"

        # Replace pattern: "stuff  word:" (multiple spaces before window name)
        # This indicates a new window on a new line
        value=$(printf '%s' "$value" | sed -E 's/  +([a-z_]+:)/;\1/g')

        # Clean up any double semicolons or leading/trailing ones
        value="${value//;;/;}"
        value="${value#;}"
        value="${value%;}"
    fi

    # Reject values containing shell metacharacters (except for command fields)
    if [[ "$key" != "pre_session_cmd" && "$key" != "tmux_layout" ]]; then
        if [[ "$value" =~ [\`\$\;\|\&] ]] || [[ "$value" == *'$('* ]]; then
            warn "Ignoring suspicious value for '$key' in $file"
            return
        fi
    fi

    case "$key" in
        worktree_dir)      WORKTREE_DIR="$value" ;;
        terminal)          TERMINAL="$value" ;;
        copy_files)        COPY_FILES="$value" ;;
        pre_session_cmd)   PRE_SESSION_CMD="$value" ;;
        tmux_layout)       TMUX_LAYOUT="$value" ;;
    esac
}

load_config() {
    WORKTREE_DIR="$DEFAULT_WORKTREE_DIR"
    TERMINAL="$DEFAULT_TERMINAL"
    COPY_FILES="$DEFAULT_COPY_FILES"
    PRE_SESSION_CMD="$DEFAULT_PRE_SESSION_CMD"
    TMUX_LAYOUT="$DEFAULT_TMUX_LAYOUT"
    ACTIVE_CONFIG="none"

    # 1. Load global config as base
    if [[ -f "$CONFIG_FILE" ]]; then
        _parse_config "$CONFIG_FILE"
        ACTIVE_CONFIG="global"
    fi

    # 2. Override with project-local config if inside a git repo
    local repo_root
    repo_root="$(git rev-parse --show-toplevel 2>/dev/null || true)"
    LOCAL_CONFIG_FILE="${repo_root:+$repo_root/.muxtree}"

    if [[ -n "$LOCAL_CONFIG_FILE" && -f "$LOCAL_CONFIG_FILE" ]]; then
        _parse_config "$LOCAL_CONFIG_FILE"
        ACTIVE_CONFIG="local"
    fi

    # Expand tilde
    WORKTREE_DIR="${WORKTREE_DIR/#\~/$HOME}"
}

ensure_git_repo() {
    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        die "Not inside a git repository. Run muxtree from within your repo."
    fi
}

get_repo_root() {
    git rev-parse --show-toplevel
}

get_repo_name() {
    basename "$(get_repo_root)"
}

get_main_branch() {
    # Try to find main/master branch
    local main_ref
    main_ref=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || true)
    if [[ -z "$main_ref" ]]; then
        # Fallback: check for common names
        for branch in main master; do
            if git show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
                main_ref="$branch"
                break
            fi
        done
    fi
    echo "${main_ref:-main}"
}

worktree_path() {
    local repo_name="$1"
    local branch="$2"
    # Sanitize branch name for safe filesystem use (strip traversal, special chars)
    local safe_branch="${branch//[^a-zA-Z0-9._-]/-}"
    safe_branch="${safe_branch#-}"  # strip leading dash
    echo "$WORKTREE_DIR/$repo_name/$safe_branch"
}

session_prefix() {
    local repo_name="$1"
    local branch="$2"
    # Allowlist: replace anything not alphanumeric, underscore, or dash
    local clean_branch="${branch//[^a-zA-Z0-9_-]/-}"
    clean_branch="${clean_branch#-}"  # strip leading dash
    echo "${repo_name}_${clean_branch}"
}

has_tmux_session() {
    tmux has-session -t "$1" 2>/dev/null
}

# ── Config Management ─────────────────────────────────────────────────────────

cmd_init() {
    logo
    echo ""

    local local_mode=false
    [[ "${1:-}" == "--local" || "${1:-}" == "-l" ]] && local_mode=true

    if $local_mode; then
        ensure_git_repo
        local repo_root
        repo_root="$(get_repo_root)"
        local target_file="$repo_root/.muxtree"

        if [[ -f "$target_file" ]]; then
            warn "Project config already exists at $target_file"
            echo ""
            cat "$target_file"
            echo ""
            read -rp "Overwrite? (y/N) " confirm
            [[ "$confirm" =~ ^[Yy]$ ]] || return 0
        fi

        echo ""
        info "Enter files to copy into new worktrees for this project (relative to repo root)."
        info "Comma-separated, e.g.: .env,.env.local,CLAUDE.md"
        read -rp "Files to copy: " input_files

        echo ""
        info "Optional: Command to run after worktree setup, before tmux session."
        info "Runs in worktree dir. Good for: bundle install, npm install, db:migrate"
        read -rp "Pre-session command: " input_pre_cmd

        echo ""
        info "Optional: Tmux layout - define windows and panes."
        info "You can define this now (single line) or edit the config file for multi-line format."
        info "Example: dev:hx|lazygit,server:bin/server,agent:"
        read -rp "Tmux layout: " input_layout

        cat > "$target_file" <<EOF
# muxtree project config
# Generated on $(date)

# Files to copy from repo root into new worktrees (comma-separated, relative to repo root)
# Supports glob patterns and directories
copy_files=$input_files

# Command to run after worktree setup, before tmux session (optional)
# Runs in worktree directory. Use for setup tasks like: bundle install, npm install
pre_session_cmd=$input_pre_cmd

# Tmux layout - define windows and panes (optional)
# Multi-line format (more readable):
# tmux_layout=[
#   dev:hx|lazygit
#   server:bin/server
#   agent:
# ]
# Or single line: tmux_layout=dev:hx|lazygit,server:bin/server,agent:
#
# Syntax:
# - ',' or newline separates windows
# - ':' separates window name from panes
# - '|' separates panes (vertical split - side by side)
# - Empty command = shell prompt
# If not set, creates default layout: dev + agent windows
tmux_layout=$input_layout
EOF

        success "Project config written to $target_file"
        echo ""
        cat "$target_file"
    else
        if [[ -f "$CONFIG_FILE" ]]; then
            warn "Config already exists at $CONFIG_FILE"
            echo ""
            cat "$CONFIG_FILE"
            echo ""
            read -rp "Overwrite? (y/N) " confirm
            [[ "$confirm" =~ ^[Yy]$ ]] || return 0
        fi

        mkdir -p "$CONFIG_DIR"

        echo ""
        read -rp "Worktree base directory [$DEFAULT_WORKTREE_DIR]: " input_dir
        local wt_dir="${input_dir:-$DEFAULT_WORKTREE_DIR}"

        read -rp "Terminal app (terminal/iterm2/ghostty/current) [$DEFAULT_TERMINAL]: " input_term
        local term="${input_term:-$DEFAULT_TERMINAL}"

        echo ""
        info "Enter files to copy into new worktrees (relative to repo root)."
        info "Comma-separated, e.g.: .env,.env.local,CLAUDE.md"
        read -rp "Files to copy: " input_files

        echo ""
        info "Optional: Command to run after worktree setup, before tmux session."
        info "Runs in worktree dir. Good for: bundle install, npm install, db:migrate"
        read -rp "Pre-session command: " input_pre_cmd

        echo ""
        info "Optional: Tmux layout - define windows and panes."
        info "You can define this now (single line) or edit the config file for multi-line format."
        info "Example: dev:hx|lazygit,server:bin/server,agent:"
        read -rp "Tmux layout: " input_layout

        cat > "$CONFIG_FILE" <<EOF
# muxtree configuration
# Generated on $(date)

# Base directory for worktrees
worktree_dir=$wt_dir

# Terminal app: terminal | iterm2 | ghostty | current
terminal=$term

# Files to copy from repo root into new worktrees (comma-separated, relative to repo root)
# Supports glob patterns and directories
copy_files=$input_files

# Command to run after worktree setup, before tmux session (optional)
# Runs in worktree directory. Use for setup tasks like: bundle install, npm install
pre_session_cmd=$input_pre_cmd

# Tmux layout - define windows and panes (optional)
# Multi-line format (more readable):
# tmux_layout=[
#   dev:hx|lazygit
#   server:bin/server
#   agent:
# ]
# Or single line: tmux_layout=dev:hx|lazygit,server:bin/server,agent:
#
# Syntax:
# - ',' or newline separates windows
# - ':' separates window name from panes
# - '|' separates panes (vertical split - side by side)
# - Empty command = shell prompt
# If not set, creates default layout: dev + agent windows
tmux_layout=$input_layout
EOF

        success "Config written to $CONFIG_FILE"
        echo ""
        cat "$CONFIG_FILE"
    fi
}

cmd_config() {
    load_config

    local has_any=false

    if [[ -f "$CONFIG_FILE" ]]; then
        has_any=true
        echo -e "${BOLD}Global config:${RESET} $CONFIG_FILE"
        echo "─────────────────────────────────"
        cat "$CONFIG_FILE"
        echo ""
    fi

    if [[ -n "${LOCAL_CONFIG_FILE:-}" && -f "$LOCAL_CONFIG_FILE" ]]; then
        has_any=true
        echo -e "${BOLD}Project config:${RESET} $LOCAL_CONFIG_FILE ${GREEN}(active)${RESET}"
        echo "─────────────────────────────────"
        cat "$LOCAL_CONFIG_FILE"
        echo ""
    elif [[ "$has_any" == true ]]; then
        echo -e "${DIM}No project config. Use ${RESET}${BOLD}muxtree init --local${RESET}${DIM} to create one.${RESET}"
    fi

    if ! $has_any; then
        warn "No config found. Run ${BOLD}muxtree init${RESET} to create one."
        return 1
    fi
}

# ── New Worktree ──────────────────────────────────────────────────────────────

cmd_new() {
    local branch=""
    local base_branch=""
    local run_cmd=""
    local bg=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --from)  base_branch="$2"; shift 2 ;;
            --run)   run_cmd="$2"; shift 2 ;;
            --bg)    bg=true; shift ;;
            -*)      die "Unknown option: $1" ;;
            *)       branch="$1"; shift ;;
        esac
    done

    [[ -n "$branch" ]] || die "Usage: muxtree new <branch-name> [--from <base-branch>] [--run claude|codex] [--bg]"

    # Validate --run command if provided
    if [[ -n "$run_cmd" ]]; then
        case "$run_cmd" in
            claude|codex) ;;
            *) die "Invalid --run command: '$run_cmd'. Allowed: claude, codex" ;;
        esac
    fi

    ensure_git_repo
    load_config

    local repo_root repo_name wt_path
    repo_root="$(get_repo_root)"
    repo_name="$(get_repo_name)"
    base_branch="${base_branch:-$(get_main_branch)}"
    wt_path="$(worktree_path "$repo_name" "$branch")"

    # Validate base branch exists
    if ! git show-ref --verify --quiet "refs/heads/$base_branch" 2>/dev/null && \
       ! git show-ref --verify --quiet "refs/remotes/origin/$base_branch" 2>/dev/null; then
        die "Base branch '$base_branch' does not exist."
    fi

    # Check if branch already exists
    if git show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
        die "Branch '$branch' already exists. Use a different name, or delete it first."
    fi

    if [[ -d "$wt_path" ]]; then
        die "Worktree already exists at $wt_path"
    fi

    # 1. Create worktree with new branch
    info "Creating worktree at ${CYAN}$wt_path${RESET}"
    mkdir -p "$(dirname "$wt_path")"
    git worktree add -b "$branch" "$wt_path" "$base_branch"
    success "Worktree created (branch ${CYAN}$branch${RESET} from ${DIM}$base_branch${RESET})"

    # 2. Copy config files
    if [[ -n "$COPY_FILES" ]]; then
        info "Copying config files..."
        IFS=',' read -ra files <<< "$COPY_FILES"
        for file in "${files[@]}"; do
            file="${file#"${file%%[![:space:]]*}"}"
            file="${file%"${file##*[![:space:]]}"}"
            [[ -n "$file" ]] || continue

            # Safe glob expansion with nullglob
            local matches
            local _old_nullglob
            _old_nullglob=$(shopt -p nullglob || true)
            shopt -s nullglob
            matches=( "$repo_root"/$file )
            eval "$_old_nullglob"

            if (( ${#matches[@]} == 0 )); then
                warn "  Not found: ${DIM}$file${RESET}"
                continue
            fi

            for match in "${matches[@]}"; do
                if [[ -e "$match" ]]; then
                    local rel="${match#"$repo_root"/}"
                    local dest="$wt_path/$rel"
                    mkdir -p -- "$(dirname -- "$dest")"
                    cp -a -- "$match" "$dest"
                    success "  Copied ${DIM}$rel${RESET}"
                fi
            done
        done
    fi

    # 3. Run pre-session command (if configured)
    if [[ -n "$PRE_SESSION_CMD" ]]; then
        info "Running pre-session command..."
        echo -e "  ${DIM}$PRE_SESSION_CMD${RESET}"
        if (cd "$wt_path" && eval "$PRE_SESSION_CMD"); then
            success "Pre-session command completed"
        else
            warn "Pre-session command failed (exit code: $?)"
            read -rp "Continue anyway? (y/N) " confirm
            [[ "$confirm" =~ ^[Yy]$ ]] || die "Aborted due to pre-session command failure"
        fi
    fi

    # 4. Launch tmux sessions
    _launch_sessions "$repo_name" "$branch" "$wt_path" "$run_cmd" "$bg"

    echo ""
    success "Ready! Worktree: ${CYAN}$wt_path${RESET}"
}

_launch_sessions() {
    local repo_name="$1"
    local branch="$2"
    local wt_path="$3"
    local run_cmd="${4:-}"
    local bg="${5:-false}"

    local sess
    sess="$(session_prefix "$repo_name" "$branch")"

    info "Creating tmux session..."

    # Use custom layout if configured, otherwise default
    if [[ -n "$TMUX_LAYOUT" ]]; then
        _create_custom_layout "$sess" "$wt_path" "$run_cmd"
    else
        _create_default_layout "$sess" "$wt_path" "$run_cmd"
    fi

    # Open terminal window (unless --bg)
    if [[ "$bg" != "true" ]]; then
        _open_terminal "$sess"
    fi
}

_create_default_layout() {
    local sess="$1"
    local wt_path="$2"
    local run_cmd="${3:-}"

    # Create session with dev window
    tmux new-session -d -s "$sess" -c "$wt_path"
    tmux rename-window -t "$sess:0" "dev"

    # Add agent window
    tmux new-window -t "$sess" -n "agent" -c "$wt_path"

    # Run command in agent window if requested
    if [[ -n "$run_cmd" ]]; then
        tmux send-keys -t "$sess:agent" "$run_cmd" Enter
    fi

    # Select dev window as default
    tmux select-window -t "$sess:dev"

    success "  Created session ${BOLD}$sess${RESET} (windows: dev, agent)"
}

_create_custom_layout() {
    local sess="$1"
    local wt_path="$2"
    local run_cmd="${3:-}"

    local layout="$TMUX_LAYOUT"
    local first_window=true
    local window_names=()

    # Parse layout: window:cmd1|cmd2;window2:cmd3
    IFS=';' read -ra windows <<< "$layout"

    for window_spec in "${windows[@]}"; do
        # Trim whitespace
        window_spec="${window_spec#"${window_spec%%[![:space:]]*}"}"
        window_spec="${window_spec%"${window_spec##*[![:space:]]}"}"
        [[ -n "$window_spec" ]] || continue

        # Split window_name:panes
        local window_name="${window_spec%%:*}"
        local panes_spec="${window_spec#*:}"

        # Trim window name
        window_name="${window_name#"${window_name%%[![:space:]]*}"}"
        window_name="${window_name%"${window_name##*[![:space:]]}"}"

        window_names+=("$window_name")

        if $first_window; then
            # Create session with first window
            tmux new-session -d -s "$sess" -c "$wt_path" -n "$window_name"
            first_window=false
        else
            # Create additional windows
            tmux new-window -t "$sess" -n "$window_name" -c "$wt_path"
        fi

        # Parse and create panes: cmd1|cmd2|cmd3
        IFS='|' read -ra panes <<< "$panes_spec"
        local first_pane=true

        for pane_cmd in "${panes[@]}"; do
            # Trim whitespace
            pane_cmd="${pane_cmd#"${pane_cmd%%[![:space:]]*}"}"
            pane_cmd="${pane_cmd%"${pane_cmd##*[![:space:]]}"}"

            if $first_pane; then
                # First pane already exists, just send command
                first_pane=false
                if [[ -n "$pane_cmd" ]]; then
                    tmux send-keys -t "$sess:$window_name.0" "$pane_cmd" Enter
                fi
            else
                # Create new pane (vertical split - side by side)
                tmux split-window -h -t "$sess:$window_name" -c "$wt_path"
                if [[ -n "$pane_cmd" ]]; then
                    tmux send-keys -t "$sess:$window_name" "$pane_cmd" Enter
                fi
            fi
        done

        # Apply even layout to this window if it has multiple panes
        if [[ ${#panes[@]} -gt 1 ]]; then
            tmux select-layout -t "$sess:$window_name" even-horizontal
        fi
    done

    # If --run flag provided and agent window exists, send command there
    if [[ -n "$run_cmd" ]]; then
        for win in "${window_names[@]}"; do
            if [[ "$win" == "agent" ]]; then
                tmux send-keys -t "$sess:agent.0" "$run_cmd" Enter
                break
            fi
        done
    fi

    # Select first window as default
    if [[ ${#window_names[@]} -gt 0 ]]; then
        tmux select-window -t "$sess:${window_names[0]}"
    fi

    success "  Created session ${BOLD}$sess${RESET} (windows: ${window_names[*]})"
}

_open_terminal() {
    local session="$1"

    # Escape double quotes and backslashes for safe AppleScript embedding
    local safe_session="${session//\\/\\\\}"
    safe_session="${safe_session//\"/\\\"}"

    case "$TERMINAL" in
        iterm2)
            osascript <<EOF 2>/dev/null || true
tell application "iTerm"
    activate
    create window with default profile
    tell current session of current window
        write text "tmux attach -t ${safe_session}"
    end tell
end tell
EOF
            ;;
        ghostty)
            # Ghostty: Use 'open -a' to open in new tab
            # Note: This opens a new tab and runs the command, but may not perfectly
            # integrate with existing windows. For better control, use 'current' mode.
            open -a Ghostty --args -e tmux attach -t "$session" 2>/dev/null || {
                warn "Failed to open Ghostty. Ensure Ghostty.app is installed."
                warn "Falling back to current terminal..."
                info "Run: tmux attach -t $session"
            }
            ;;
        current)
            # Attach in the current terminal (works with any terminal app)
            info "Attaching to session in current terminal: ${BOLD}$session${RESET}"
            tmux attach -t "$session" 2>/dev/null || {
                warn "Could not attach automatically. Run: tmux attach -t $session"
            }
            ;;
        terminal|*)
            osascript <<EOF 2>/dev/null || true
tell application "Terminal"
    activate
    do script "tmux attach -t ${safe_session}"
end tell
EOF
            ;;
    esac
}

# ── List Worktrees ────────────────────────────────────────────────────────────

cmd_list() {
    ensure_git_repo
    load_config

    local repo_name
    repo_name="$(get_repo_name)"
    local wt_base="$WORKTREE_DIR/$repo_name"

    echo -e "${BOLD}Worktrees for ${CYAN}$repo_name${RESET}"
    echo "════════════════════════════════════════════════════════════════"

    if [[ ! -d "$wt_base" ]]; then
        info "No worktrees found. Use ${BOLD}muxtree new <branch>${RESET} to create one."
        return 0
    fi

    local found=false

    # Iterate through git worktrees and match our managed ones
    while IFS= read -r wt_line; do
        local wt_dir branch_name

        wt_dir="$(echo "$wt_line" | awk '{print $1}')"
        branch_name="$(echo "$wt_line" | sed -n 's/.*\[\(.*\)\].*/\1/p')"

        # Skip detached HEAD worktrees
        [[ -n "$branch_name" ]] || continue

        # Skip worktrees not in our managed directory
        [[ "$wt_dir" == "$wt_base"/* ]] || continue

        found=true

        local sess
        sess="$(session_prefix "$repo_name" "$branch_name")"

        # Diff stats
        local diff_stat=""
        if [[ -d "$wt_dir/.git" || -f "$wt_dir/.git" ]]; then
            local insertions deletions
            insertions=$(git -C "$wt_dir" diff --stat HEAD 2>/dev/null | tail -1 | grep -oE '[0-9]+ insertion' | grep -oE '[0-9]+' || echo "0")
            deletions=$(git -C "$wt_dir" diff --stat HEAD 2>/dev/null | tail -1 | grep -oE '[0-9]+ deletion' | grep -oE '[0-9]+' || echo "0")

            # Also count staged changes
            local staged_ins staged_del
            staged_ins=$(git -C "$wt_dir" diff --cached --stat HEAD 2>/dev/null | tail -1 | grep -oE '[0-9]+ insertion' | grep -oE '[0-9]+' || echo "0")
            staged_del=$(git -C "$wt_dir" diff --cached --stat HEAD 2>/dev/null | tail -1 | grep -oE '[0-9]+ deletion' | grep -oE '[0-9]+' || echo "0")

            local total_ins=$(( ${insertions:-0} + ${staged_ins:-0} ))
            local total_del=$(( ${deletions:-0} + ${staged_del:-0} ))

            diff_stat="${GREEN}+${total_ins}${RESET} ${RED}-${total_del}${RESET}"
        fi

        # Tmux session status
        local sess_status
        if has_tmux_session "$sess"; then
            sess_status="${GREEN}●${RESET}"
        else
            sess_status="${DIM}○${RESET}"
        fi

        echo ""
        echo -e "  ${BOLD}${CYAN}$branch_name${RESET}  $diff_stat"
        echo -e "  ${DIM}$wt_dir${RESET}"
        echo -e "  Session: $sess_status $sess"

    done < <(git worktree list)

    if ! $found; then
        info "No managed worktrees found. Use ${BOLD}muxtree new <branch>${RESET} to create one."
    fi

    echo ""
}

# ── Delete Worktree ───────────────────────────────────────────────────────────

cmd_delete() {
    local branch=""
    local force=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f) force=true; shift ;;
            -*)         die "Unknown option: $1" ;;
            *)          branch="$1"; shift ;;
        esac
    done

    [[ -n "$branch" ]] || die "Usage: muxtree delete <branch-name> [--force|-f]"

    ensure_git_repo
    load_config

    local repo_name wt_path
    repo_name="$(get_repo_name)"
    wt_path="$(worktree_path "$repo_name" "$branch")"

    if [[ ! -d "$wt_path" ]]; then
        die "Worktree not found: $wt_path"
    fi

    # Show diff stats before confirming
    local insertions deletions
    insertions=$(git -C "$wt_path" diff --stat HEAD 2>/dev/null | tail -1 | grep -oE '[0-9]+ insertion' | grep -oE '[0-9]+' || echo "0")
    deletions=$(git -C "$wt_path" diff --stat HEAD 2>/dev/null | tail -1 | grep -oE '[0-9]+ deletion' | grep -oE '[0-9]+' || echo "0")

    # Also count staged changes
    local staged_ins staged_del
    staged_ins=$(git -C "$wt_path" diff --cached --stat HEAD 2>/dev/null | tail -1 | grep -oE '[0-9]+ insertion' | grep -oE '[0-9]+' || echo "0")
    staged_del=$(git -C "$wt_path" diff --cached --stat HEAD 2>/dev/null | tail -1 | grep -oE '[0-9]+ deletion' | grep -oE '[0-9]+' || echo "0")

    local total_ins=$(( ${insertions:-0} + ${staged_ins:-0} ))
    local total_del=$(( ${deletions:-0} + ${staged_del:-0} ))

    echo ""
    echo -e "  Branch:    ${BOLD}$branch${RESET}"
    echo -e "  Path:      ${DIM}$wt_path${RESET}"
    echo -e "  Changes:   ${GREEN}+${total_ins}${RESET} ${RED}-${total_del}${RESET}"
    echo ""

    if ! $force; then
        warn "This will remove the worktree and delete the local branch."
        read -rp "Are you sure? (y/N) " confirm
        [[ "$confirm" =~ ^[Yy]$ ]] || { info "Cancelled."; return 0; }
    fi

    # Kill tmux sessions
    _kill_sessions "$repo_name" "$branch"

    # Remove worktree
    info "Removing worktree..."
    git worktree remove "$wt_path" --force 2>/dev/null || {
        warn "git worktree remove failed, cleaning up manually..."
        rm -rf -- "$wt_path"
        git worktree prune
    }
    success "Worktree removed"

    # Delete the branch
    info "Deleting branch ${CYAN}$branch${RESET}..."
    git branch -D "$branch" 2>/dev/null && success "Branch deleted" || warn "Branch may have already been deleted"

    # Clean up empty repo dir
    local repo_dir="$WORKTREE_DIR/$repo_name"
    if [[ -d "$repo_dir" ]]; then
        local _old_dotglob _old_nullglob_del
        _old_dotglob=$(shopt -p dotglob || true)
        _old_nullglob_del=$(shopt -p nullglob || true)
        shopt -s nullglob dotglob
        local _dir_files=("$repo_dir"/*)
        eval "$_old_dotglob"
        eval "$_old_nullglob_del"
        if (( ${#_dir_files[@]} == 0 )); then
            rmdir -- "$repo_dir" 2>/dev/null || true
        fi
    fi

    echo ""
    success "Done."
}

# ── Session Management ────────────────────────────────────────────────────────

cmd_sessions() {
    local action="${1:-}"
    local branch="${2:-}"
    local run_cmd=""
    local bg=false

    # Parse remaining args
    local extra_arg=""
    shift 2 2>/dev/null || true
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --run) run_cmd="$2"; shift 2 ;;
            --bg)  bg=true; shift ;;
            -*)    die "Unknown option: $1" ;;
            *)     extra_arg="$1"; shift ;;
        esac
    done

    case "$action" in
        open|launch|start)
            [[ -n "$branch" ]] || die "Usage: muxtree sessions open <branch> [--run claude|codex] [--bg]"
            if [[ -n "$run_cmd" ]]; then
                case "$run_cmd" in
                    claude|codex) ;;
                    *) die "Invalid --run command: '$run_cmd'. Allowed: claude, codex" ;;
                esac
            fi
            _sessions_open "$branch" "$run_cmd" "$bg"
            ;;
        close|kill|stop)
            [[ -n "$branch" ]] || die "Usage: muxtree sessions close <branch>"
            _sessions_close "$branch"
            ;;
        relaunch|restart)
            [[ -n "$branch" ]] || die "Usage: muxtree sessions relaunch <branch> [--run claude|codex] [--bg]"
            if [[ -n "$run_cmd" ]]; then
                case "$run_cmd" in
                    claude|codex) ;;
                    *) die "Invalid --run command: '$run_cmd'. Allowed: claude, codex" ;;
                esac
            fi
            _sessions_close "$branch"
            _sessions_open "$branch" "$run_cmd" "$bg"
            ;;
        attach)
            [[ -n "$branch" ]] || die "Usage: muxtree sessions attach <branch> [dev|agent]"
            _sessions_attach "$branch" "${extra_arg:-}"
            ;;
        *)
            die "Usage: muxtree sessions <open|close|relaunch|attach> <branch> [--run claude|codex] [--bg]"
            ;;
    esac
}

_sessions_open() {
    local branch="$1"
    local run_cmd="$2"
    local bg="${3:-false}"

    ensure_git_repo
    load_config

    local repo_name wt_path
    repo_name="$(get_repo_name)"
    wt_path="$(worktree_path "$repo_name" "$branch")"

    [[ -d "$wt_path" ]] || die "Worktree not found: $wt_path"

    local sess
    sess="$(session_prefix "$repo_name" "$branch")"

    if has_tmux_session "$sess"; then
        warn "Session $sess already exists"
    else
        # Use custom layout if configured, otherwise default
        if [[ -n "$TMUX_LAYOUT" ]]; then
            _create_custom_layout "$sess" "$wt_path" "$run_cmd"
        else
            _create_default_layout "$sess" "$wt_path" "$run_cmd"
        fi

        # Open terminal window (unless --bg)
        if [[ "$bg" != "true" ]]; then
            _open_terminal "$sess"
        fi
    fi
}

_sessions_close() {
    local branch="$1"

    ensure_git_repo
    load_config

    local repo_name
    repo_name="$(get_repo_name)"

    _kill_sessions "$repo_name" "$branch"
}

_sessions_attach() {
    local branch="$1"
    local window="${2:-}"

    ensure_git_repo
    load_config

    local repo_name sess
    repo_name="$(get_repo_name)"
    sess="$(session_prefix "$repo_name" "$branch")"

    if ! has_tmux_session "$sess"; then
        die "Session not found: $sess"
    fi

    # Select window if specified
    if [[ -n "$window" ]]; then
        case "$window" in
            dev|agent) tmux select-window -t "$sess:$window" ;;
            *) die "Unknown window: $window (use dev or agent)" ;;
        esac
    fi

    tmux attach -t "$sess"
}

_kill_sessions() {
    local repo_name="$1"
    local branch="$2"

    local sess
    sess="$(session_prefix "$repo_name" "$branch")"

    if has_tmux_session "$sess"; then
        tmux kill-session -t "$sess"
        success "Killed session ${BOLD}$sess${RESET}"
    fi
}

# ── Help ──────────────────────────────────────────────────────────────────────

cmd_help() {
    logo
    echo -e "

${BOLD}USAGE${RESET}
    muxtree <command> [options]

${BOLD}COMMANDS${RESET}
    ${CYAN}init${RESET}                              Set up global config (~/.muxtree/config)
        --local                       Create project config (.muxtree in repo root)
    ${CYAN}config${RESET}                            Show current config (global + project)

        Terminal options: terminal, iterm2, ghostty, current
        - terminal: macOS Terminal.app (new window)
        - iterm2: iTerm2 (new window)
        - ghostty: Ghostty (new tab via 'open -a')
        - current: Attach in currently active terminal (any app)

    ${CYAN}new${RESET} <branch> [options]             Create worktree + tmux session
        --from <branch>               Base branch (default: main/master)
        --run <claude|codex>          Auto-run command in agent window
        --bg                          Create session without opening terminal

    ${CYAN}list${RESET}                              List worktrees, diff stats, session status

    ${CYAN}delete${RESET} <branch> [--force]          Delete worktree and branch (with confirmation)

    ${CYAN}sessions${RESET} <action> <branch> [opts]  Manage tmux session for a worktree
        open   <branch> [--run cmd]   Create session & open terminal
        close  <branch>               Kill tmux session
        relaunch <branch> [--run cmd] Close + reopen session
        attach <branch> [dev|agent]   Attach to session (optionally select window)

    ${CYAN}help${RESET}                              Show this help message

${BOLD}EXAMPLES${RESET}
    muxtree init                          # Global setup
    muxtree init --local                  # Project-specific copy_files
    muxtree new feature-auth              # New worktree from main
    muxtree new fix-bug --from develop    # New worktree from develop
    muxtree new feature-ai --run claude   # Auto-launch claude code
    muxtree new fix-bug --bg              # Create without opening terminals
    muxtree list                          # Show all worktrees + status
    muxtree sessions close feature-auth   # Kill tmux sessions
    muxtree sessions relaunch fix-bug     # Restart sessions
    muxtree delete feature-auth           # Remove worktree + branch

${BOLD}CONFIG${RESET}
    Global:  ~/.muxtree/config
             (worktree_dir, terminal, copy_files, pre_session_cmd, tmux_layout)
    Project: .muxtree in repo root      (overrides global settings)
    Env:     MUXTREE_CONFIG_DIR=/path    (override global config dir)

    ${BOLD}Hooks & Layout:${RESET}
    - pre_session_cmd:  Runs after worktree setup, before tmux session
                        Good for: bundle install, npm install, db:migrate

    - tmux_layout:      Define custom tmux windows and panes
                        Multi-line format (recommended):
                        tmux_layout=[
                          dev:hx|lazygit
                          server:cd api && bin/server|cd ui && yarn start
                          logs:tail -f log/development.log
                          agent:
                        ]

                        Single-line format: dev:hx|lazygit,server:bin/server,agent:

                        Syntax:
                        - ',' or newline separates windows
                        - ':' separates window name from panes
                        - '|' separates panes (vertical split - side by side)
                        - Empty command = shell prompt

                        If not set, creates default: dev + agent windows
"
}

# ── Main Dispatch ─────────────────────────────────────────────────────────────

main() {
    local cmd="${1:-help}"
    shift 2>/dev/null || true

    case "$cmd" in
        init)       cmd_init "$@" ;;
        config)     cmd_config "$@" ;;
        new)        cmd_new "$@" ;;
        list|ls)    cmd_list "$@" ;;
        delete|rm)  cmd_delete "$@" ;;
        sessions|s) cmd_sessions "$@" ;;
        help|-h|--help) cmd_help ;;
        version|-v|--version) echo "muxtree v$VERSION" ;;
        *)          die "Unknown command: $cmd. Run 'muxtree help' for usage." ;;
    esac
}

main "$@"
